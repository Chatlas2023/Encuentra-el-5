<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Romper Ladrillos</title>
    <style>
        body {
    margin: 0;
    padding: 0;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    touch-action: manipulation;
    overflow: hidden;
}

#game-container {
    width: 100%;
    max-width: 400px;
    position: relative;
}

#gameCanvas {
    background: #111;
    display: block;
    width: 100%;
    touch-action: none;
    border-radius: 8px; /* Bordes redondeados */
}
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script>
        let lives = 10; // Inicia con 10 vidas
        const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Ajustar tamaño del canvas para móviles
function resizeCanvas() {
    const container = document.getElementById("game-container");
    canvas.width = container.offsetWidth;
    canvas.height = window.innerHeight * 0.7; // Altura adaptable
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Variables del juego
let ballX = canvas.width / 2;
let ballY = canvas.height - 30;
let ballRadius = 10;
let ballSpeedX = 4;
let ballSpeedY = -4;

let paddleWidth = 80;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;

let rightPressed = false;
let leftPressed = false;
        let isGameOver = false;

// Ladrillos
const brickRowCount = 8;
const brickColumnCount = 6;
const brickWidth = 50;
const brickHeight = 15;
const brickPadding = 8;
const brickOffsetTop = 30;
const brickOffsetLeft = 20;
        const brickColors = [
    "#FF5252", // Rojo
    "#FF9800", // Naranja
    "#FFEB3B", // Amarillo
    "#4CAF50", // Verde
    "#2196F3", // Azul
    "#9C27B0", // Morado
    "#E91E63", // Rosa
    "#FFFFFF"  // Blanco
];

const bricks = [];
for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
    }
}

// Controles táctiles para móvil
canvas.addEventListener("touchmove", (e) => {
    const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
    paddleX = touchX - paddleWidth / 2;
    // Limitar la paleta dentro del canvas
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
});

// Dibujar elementos
function drawBall() {
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
}

function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
            if (bricks[c][r].status === 1) {
                const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = brickColors[r]; // Color basado en la fila (r)
                ctx.fill();
                ctx.closePath();
            }
        }
    }
}

// Colisiones
function collisionDetection() {
    for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
            const brick = bricks[c][r];
            if (brick.status === 1) {
                if (
                    ballX > brick.x &&
                    ballX < brick.x + brickWidth &&
                    ballY > brick.y &&
                    ballY < brick.y + brickHeight
                ) {
                    ballSpeedY = -ballSpeedY;
                    brick.status = 0;
                }
            }
        }
    }
}
function drawLives() {
    const heartIcon = "❤️";
    const heartSpacing = 30; // Espacio entre corazones
    const startX = canvas.width - 40; // Posición inicial (esquina derecha)
    
    ctx.font = "24px Arial";
    ctx.fillStyle = "#FF5252"; // Rojo
    ctx.textAlign = "right";
    
    // Dibuja un corazón por cada vida restante
    for (let i = 0; i < lives; i++) {
        ctx.fillText(heartIcon, startX - (i * heartSpacing), 30);
    }
}
// Bucle principal del juego
function gameLoop() {
        if (isGameOver) {
        // Mostrar mensaje de Game Over
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFF";
        ctx.font = "36px Arial";
        ctx.textAlign = "center";
        ctx.fillText("¡Game Over!", canvas.width / 2, canvas.height / 2);
        ctx.font = "24px Arial";
        ctx.fillText("Reiniciando...", canvas.width / 2, canvas.height / 2 + 40);
        return; // Detener el bucle hasta que se reinicie
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    drawLives();
    collisionDetection();

    // Rebote en paredes laterales
    if (ballX + ballSpeedX > canvas.width - ballRadius || ballX + ballSpeedX < ballRadius) {
        ballSpeedX = -ballSpeedX;
    }
    
    // Rebote en techo
    if (ballY + ballSpeedY < ballRadius) {
        ballSpeedY = -ballSpeedY;
    }
    
    // Rebote en paleta o pérdida de vida
// Rebote en paleta o pérdida de vida
if (ballY + ballSpeedY > canvas.height - ballRadius) {
    if (ballX > paddleX - ballRadius && ballX < paddleX + paddleWidth + ballRadius) {
        ballSpeedY = -ballSpeedY; // Rebote en la paleta
    } else {
        lives--; // Restar una vida
        if (lives === 0) {  // Cambiado de <= a ===
            alert("¡Game Over!");
            document.location.reload();
        } else {
            ctx.fillStyle = "#FFF";
            ctx.font = "24px Arial";
            ctx.fillText("¡Listo!", canvas.width / 2 - 40, canvas.height / 2);
            // Pausa de 1 segundo antes de reiniciar
            setTimeout(() => {
                ballX = canvas.width / 2;
                ballY = canvas.height - 30;
                ballSpeedX = 4;
                ballSpeedY = -4;
                paddleX = (canvas.width - paddleWidth) / 2;
            }, 1000);
        }
    }
}

    ballX += ballSpeedX;
    ballY += ballSpeedY;
    requestAnimationFrame(gameLoop); // ¡Esta línea debe estar FUERA del else!
}

gameLoop();
    </script>
</body>
</html>
