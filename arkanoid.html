<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Romper Ladrillos</title>
    <style>
        body {
    margin: 0;
    padding: 0;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    touch-action: manipulation;
    overflow: hidden;
}

#game-container {
    width: 100%;
    max-width: 400px;
    position: relative;
}

#gameCanvas {
    background: #111;
    display: block;
    width: 100%;
    touch-action: none;
}
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script>
        let lives = 10; // Inicia con 10 vidas
        const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Ajustar tamaño del canvas para móviles
function resizeCanvas() {
    const container = document.getElementById("game-container");
    canvas.width = container.offsetWidth;
    canvas.height = window.innerHeight * 0.7; // Altura adaptable
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Variables del juego
let ballX = canvas.width / 2;
let ballY = canvas.height - 30;
let ballRadius = 10;
let ballSpeedX = 4;
let ballSpeedY = -4;

let paddleWidth = 80;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;

let rightPressed = false;
let leftPressed = false;

// Ladrillos
const brickRowCount = 8;
const brickColumnCount = 6;
const brickWidth = 50;
const brickHeight = 15;
const brickPadding = 8;
const brickOffsetTop = 30;
const brickOffsetLeft = 20;
        const brickColors = [
    "#FF5252", // Rojo
    "#FF9800", // Naranja
    "#FFEB3B", // Amarillo
    "#4CAF50", // Verde
    "#2196F3", // Azul
    "#9C27B0", // Morado
    "#E91E63", // Rosa
    "#FFFFFF"  // Blanco
];

const bricks = [];
for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
    }
}

// Controles táctiles para móvil
canvas.addEventListener("touchmove", (e) => {
    const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
    paddleX = touchX - paddleWidth / 2;
    // Limitar la paleta dentro del canvas
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
});

// Dibujar elementos
function drawBall() {
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.closePath();
}

function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
            if (bricks[c][r].status === 1) {
                const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = brickColors[r]; // Color basado en la fila (r)
                ctx.fill();
                ctx.closePath();
            }
        }
    }
}

// Colisiones
function collisionDetection() {
    for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
            const brick = bricks[c][r];
            if (brick.status === 1) {
                if (
                    ballX > brick.x &&
                    ballX < brick.x + brickWidth &&
                    ballY > brick.y &&
                    ballY < brick.y + brickHeight
                ) {
                    ballSpeedY = -ballSpeedY;
                    brick.status = 0;
                }
            }
        }
    }
}
function drawLives() {
    ctx.font = "bold 20px 'Arial'";
    ctx.fillStyle = "#FFD700"; // Dorado
    ctx.textAlign = "left";
    ctx.fillText("❤️ " + lives, 20, 25);
}
// Bucle principal del juego
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    drawLives();
    collisionDetection();

    // Rebote en paredes laterales
    if (ballX + ballSpeedX > canvas.width - ballRadius || ballX + ballSpeedX < ballRadius) {
        ballSpeedX = -ballSpeedX;
    }
    
    // Rebote en techo
    if (ballY + ballSpeedY < ballRadius) {
        ballSpeedY = -ballSpeedY;
    }
    
    // Rebote en paleta o pérdida de vida
    if (ballY + ballSpeedY > canvas.height - ballRadius) {
        if (ballX > paddleX - ballRadius && ballX < paddleX + paddleWidth + ballRadius) {
            ballSpeedY = -ballSpeedY;
        } else {
            lives--;
            if (lives <= 0) {
                alert("¡Game Over!");
                document.location.reload();
            } else {
                ctx.fillStyle = "#FFF";
                ctx.font = "24px Arial";
                ctx.fillText("¡Listo!", canvas.width / 2 - 40, canvas.height / 2);
                setTimeout(() => {
                    ballX = canvas.width / 2;
                    ballY = canvas.height - 30;
                    ballSpeedX = 4;
                    ballSpeedY = -4;
                    paddleX = (canvas.width - paddleWidth) / 2;
                }, 1000); // Espera 1 segundo
            }
        }
    }

    ballX += ballSpeedX;
    ballY += ballSpeedY;
    requestAnimationFrame(gameLoop); // ¡Esta línea debe estar FUERA del else!
}

gameLoop();
    </script>
</body>
</html>
